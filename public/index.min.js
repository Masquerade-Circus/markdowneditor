(function () {
	'use strict';

	(function(a,c,d,f){if("ontouchstart"in c||c.a&&a instanceof DocumentTouch){var b=null,e=function(){b&&(b.classList.remove(d), b=null);};a.body.addEventListener("touchstart",function(a){e();f(a)&&(b=a.target, b.classList.add(d));},!1);a.body.addEventListener("touchmove",e,!1);}})(document,window,"active",function(a){return-1<["A","INPUT"].indexOf(a.target.tagName)});

	function Vnode(tag, key, attrs, children, text, dom) {
		return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
	}
	Vnode.normalize = function(node) {
		if (Array.isArray(node)) { return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined) }
		if (node != null && typeof node !== "object") { return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined) }
		return node
	};
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i]);
		}
		return children
	};

	var vnode = Vnode;

	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
	var selectorCache = {};
	var hasOwn = {}.hasOwnProperty;

	function isEmpty(object) {
		for (var key in object) { if (hasOwn.call(object, key)) { return false } }
		return true
	}

	function compileSelector(selector) {
		var match, tag = "div", classes = [], attrs = {};
		while (match = selectorParser.exec(selector)) {
			var type = match[1], value = match[2];
			if (type === "" && value !== "") { tag = value; }
			else if (type === "#") { attrs.id = value; }
			else if (type === ".") { classes.push(value); }
			else if (match[3][0] === "[") {
				var attrValue = match[6];
				if (attrValue) { attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\"); }
				if (match[4] === "class") { classes.push(attrValue); }
				else { attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true; }
			}
		}
		if (classes.length > 0) { attrs.className = classes.join(" "); }
		return selectorCache[selector] = {tag: tag, attrs: attrs}
	}

	function execSelector(state, attrs, children) {
		var hasAttrs = false, childList, text;
		var className = attrs.className || attrs.class;

		if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
			var newAttrs = {};

			for(var key in attrs) {
				if (hasOwn.call(attrs, key)) {
					newAttrs[key] = attrs[key];
				}
			}

			attrs = newAttrs;
		}

		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key];
			}
		}

		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined;
				attrs.className = className;
			}

			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className;
			}
		}

		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true;
				break
			}
		}

		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children;
		} else {
			childList = children;
		}

		return vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
	}

	function hyperscript(selector) {
		var arguments$1 = arguments;

		// Because sloppy mode sucks
		var attrs = arguments[1], start = 2, children;

		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}

		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector);
		}

		if (attrs == null) {
			attrs = {};
		} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {};
			start = 1;
		}

		if (arguments.length === start + 1) {
			children = arguments[start];
			if (!Array.isArray(children)) { children = [children]; }
		} else {
			children = [];
			while (start < arguments.length) { children.push(arguments$1[start++]); }
		}

		var normalized = vnode.normalizeChildren(children);

		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized)
		} else {
			return vnode(selector, attrs.key, attrs, normalized)
		}
	}

	var hyperscript_1 = hyperscript;

	var trust = function(html) {
		if (html == null) { html = ""; }
		return vnode("<", undefined, undefined, html, undefined, undefined)
	};

	var fragment = function(attrs, children) {
		return vnode("[", attrs.key, attrs, vnode.normalizeChildren(children), undefined, undefined)
	};

	hyperscript_1.trust = trust;
	hyperscript_1.fragment = fragment;

	var hyperscript_1$1 = hyperscript_1;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var promise = createCommonjsModule(function (module) {
	/** @constructor */
	var PromisePolyfill = function(executor) {
		if (!(this instanceof PromisePolyfill)) { throw new Error("Promise must be called with `new`") }
		if (typeof executor !== "function") { throw new TypeError("executor must be a function") }

		var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false);
		var instance = self._instance = {resolvers: resolvers, rejectors: rejectors};
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then;
				try {
					if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) { throw new TypeError("Promise can't be resolved w/ itself") }
						executeOnce(then.bind(value));
					}
					else {
						callAsync(function() {
							if (!shouldAbsorb && list.length === 0) { console.error("Possible unhandled promise rejection:", value); }
							for (var i = 0; i < list.length; i++) { list[i](value); }
							resolvers.length = 0, rejectors.length = 0;
							instance.state = shouldAbsorb;
							instance.retry = function() {execute(value);};
						});
					}
				}
				catch (e) {
					rejectCurrent(e);
				}
			}
		}
		function executeOnce(then) {
			var runs = 0;
			function run(fn) {
				return function(value) {
					if (runs++ > 0) { return }
					fn(value);
				}
			}
			var onerror = run(rejectCurrent);
			try {then(run(resolveCurrent), onerror);} catch (e) {onerror(e);}
		}

		executeOnce(executor);
	};
	PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
		var self = this, instance = self._instance;
		function handle(callback, list, next, state) {
			list.push(function(value) {
				if (typeof callback !== "function") { next(value); }
				else { try {resolveNext(callback(value));} catch (e) {if (rejectNext) { rejectNext(e); }} }
			});
			if (typeof instance.retry === "function" && state === instance.state) { instance.retry(); }
		}
		var resolveNext, rejectNext;
		var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject;});
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
		return promise
	};
	PromisePolyfill.prototype.catch = function(onRejection) {
		return this.then(null, onRejection)
	};
	PromisePolyfill.resolve = function(value) {
		if (value instanceof PromisePolyfill) { return value }
		return new PromisePolyfill(function(resolve) {resolve(value);})
	};
	PromisePolyfill.reject = function(value) {
		return new PromisePolyfill(function(resolve, reject) {reject(value);})
	};
	PromisePolyfill.all = function(list) {
		return new PromisePolyfill(function(resolve, reject) {
			var total = list.length, count = 0, values = [];
			if (list.length === 0) { resolve([]); }
			else { for (var i = 0; i < list.length; i++) {
				(function(i) {
					function consume(value) {
						count++;
						values[i] = value;
						if (count === total) { resolve(values); }
					}
					if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject);
					}
					else { consume(list[i]); }
				})(i);
			} }
		})
	};
	PromisePolyfill.race = function(list) {
		return new PromisePolyfill(function(resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject);
			}
		})
	};

	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") { window.Promise = PromisePolyfill; }
		module.exports = window.Promise;
	} else if (typeof commonjsGlobal !== "undefined") {
		if (typeof commonjsGlobal.Promise === "undefined") { commonjsGlobal.Promise = PromisePolyfill; }
		module.exports = commonjsGlobal.Promise;
	} else {
		module.exports = PromisePolyfill;
	}
	});

	var build = function(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") { return "" }

		var args = [];
		for (var key in object) {
			destructure(key, object[key]);
		}

		return args.join("&")

		function destructure(key, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key + "[" + i + "]", value[i]);
				}
			}
			else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key + "[" + i + "]", value[i]);
				}
			}
			else { args.push(encodeURIComponent(key) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : "")); }
		}
	};

	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i");

	var request = function($window, Promise) {
		var callbackCount = 0;

		var oncompletion;
		function setCompletionCallback(callback) {oncompletion = callback;}

		function finalizer() {
			var count = 0;
			function complete() {if (--count === 0 && typeof oncompletion === "function") { oncompletion(); }}

			return function finalize(promise) {
				var then = promise.then;
				promise.then = function() {
					count++;
					var next = then.apply(promise, arguments);
					next.then(complete, function(e) {
						complete();
						if (count === 0) { throw e }
					});
					return finalize(next)
				};
				return promise
			}
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args;
				args = extra || {};
				if (args.url == null) { args.url = url; }
			}
			return args
		}

		function request(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);

			var promise = new Promise(function(resolve, reject) {
				if (args.method == null) { args.method = "GET"; }
				args.method = args.method.toUpperCase();

				var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true);

				if (typeof args.serialize !== "function") { args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify; }
				if (typeof args.deserialize !== "function") { args.deserialize = deserialize; }
				if (typeof args.extract !== "function") { args.extract = extract; }

				args.url = interpolate(args.url, args.data);
				if (useBody) { args.data = args.serialize(args.data); }
				else { args.url = assemble(args.url, args.data); }

				var xhr = new $window.XMLHttpRequest(),
					aborted = false,
					_abort = xhr.abort;


				xhr.abort = function abort() {
					aborted = true;
					_abort.call(xhr);
				};

				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);

				if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
				}
				if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
					xhr.setRequestHeader("Accept", "application/json, text/*");
				}
				if (args.withCredentials) { xhr.withCredentials = args.withCredentials; }

				for (var key in args.headers) { if ({}.hasOwnProperty.call(args.headers, key)) {
					xhr.setRequestHeader(key, args.headers[key]);
				} }

				if (typeof args.config === "function") { xhr = args.config(xhr, args) || xhr; }

				xhr.onreadystatechange = function() {
					// Don't throw errors on xhr.abort().
					if(aborted) { return }

					if (xhr.readyState === 4) {
						try {
							var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args));
							if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response));
							}
							else {
								var error = new Error(xhr.responseText);
								for (var key in response) { error[key] = response[key]; }
								reject(error);
							}
						}
						catch (e) {
							reject(e);
						}
					}
				};

				if (useBody && (args.data != null)) { xhr.send(args.data); }
				else { xhr.send(); }
			});
			return args.background === true ? promise : finalize(promise)
		}

		function jsonp(args, extra) {
			var finalize = finalizer();
			args = normalize(args, extra);

			var promise = new Promise(function(resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
				var script = $window.document.createElement("script");
				$window[callbackName] = function(data) {
					script.parentNode.removeChild(script);
					resolve(cast(args.type, data));
					delete $window[callbackName];
				};
				script.onerror = function() {
					script.parentNode.removeChild(script);
					reject(new Error("JSONP request failed"));
					delete $window[callbackName];
				};
				if (args.data == null) { args.data = {}; }
				args.url = interpolate(args.url, args.data);
				args.data[args.callbackKey || "callback"] = callbackName;
				script.src = assemble(args.url, args.data);
				$window.document.documentElement.appendChild(script);
			});
			return args.background === true? promise : finalize(promise)
		}

		function interpolate(url, data) {
			if (data == null) { return url }

			var tokens = url.match(/:[^\/]+/gi) || [];
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key]);
				}
			}
			return url
		}

		function assemble(url, data) {
			var querystring = build(data);
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&";
				url += prefix + querystring;
			}
			return url
		}

		function deserialize(data) {
			try {return data !== "" ? JSON.parse(data) : null}
			catch (e) {throw new Error(data)}
		}

		function extract(xhr) {return xhr.responseText}

		function cast(type, data) {
			if (typeof type === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type(data[i]);
					}
				}
				else { return new type(data) }
			}
			return data
		}

		return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
	};

	var request$1 = request(window, promise);

	var render = function($window) {
		var $doc = $window.document;
		var $emptyFragment = $doc.createDocumentFragment();

		var nameSpace = {
			svg: "http://www.w3.org/2000/svg",
			math: "http://www.w3.org/1998/Math/MathML"
		};

		var onevent;
		function setEventCallback(callback) {return onevent = callback}

		function getNameSpace(vnode$$1) {
			return vnode$$1.attrs && vnode$$1.attrs.xmlns || nameSpace[vnode$$1.tag]
		}

		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode$$1 = vnodes[i];
				if (vnode$$1 != null) {
					createNode(parent, vnode$$1, hooks, ns, nextSibling);
				}
			}
		}
		function createNode(parent, vnode$$1, hooks, ns, nextSibling) {
			var tag = vnode$$1.tag;
			if (typeof tag === "string") {
				vnode$$1.state = {};
				if (vnode$$1.attrs != null) { initLifecycle(vnode$$1.attrs, vnode$$1, hooks); }
				switch (tag) {
					case "#": return createText(parent, vnode$$1, nextSibling)
					case "<": return createHTML(parent, vnode$$1, nextSibling)
					case "[": return createFragment(parent, vnode$$1, hooks, ns, nextSibling)
					default: return createElement(parent, vnode$$1, hooks, ns, nextSibling)
				}
			}
			else { return createComponent(parent, vnode$$1, hooks, ns, nextSibling) }
		}
		function createText(parent, vnode$$1, nextSibling) {
			vnode$$1.dom = $doc.createTextNode(vnode$$1.children);
			insertNode(parent, vnode$$1.dom, nextSibling);
			return vnode$$1.dom
		}
		function createHTML(parent, vnode$$1, nextSibling) {
			var match = vnode$$1.children.match(/^\s*?<(\w+)/im) || [];
			var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match[1]] || "div";
			var temp = $doc.createElement(parent1);

			temp.innerHTML = vnode$$1.children;
			vnode$$1.dom = temp.firstChild;
			vnode$$1.domSize = temp.childNodes.length;
			var fragment = $doc.createDocumentFragment();
			var child;
			while (child = temp.firstChild) {
				fragment.appendChild(child);
			}
			insertNode(parent, fragment, nextSibling);
			return fragment
		}
		function createFragment(parent, vnode$$1, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment();
			if (vnode$$1.children != null) {
				var children = vnode$$1.children;
				createNodes(fragment, children, 0, children.length, hooks, null, ns);
			}
			vnode$$1.dom = fragment.firstChild;
			vnode$$1.domSize = fragment.childNodes.length;
			insertNode(parent, fragment, nextSibling);
			return fragment
		}
		function createElement(parent, vnode$$1, hooks, ns, nextSibling) {
			var tag = vnode$$1.tag;
			var attrs = vnode$$1.attrs;
			var is = attrs && attrs.is;

			ns = getNameSpace(vnode$$1) || ns;

			var element = ns ?
				is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
				is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag);
			vnode$$1.dom = element;

			if (attrs != null) {
				setAttrs(vnode$$1, attrs, ns);
			}

			insertNode(parent, element, nextSibling);

			if (vnode$$1.attrs != null && vnode$$1.attrs.contenteditable != null) {
				setContentEditable(vnode$$1);
			}
			else {
				if (vnode$$1.text != null) {
					if (vnode$$1.text !== "") { element.textContent = vnode$$1.text; }
					else { vnode$$1.children = [vnode("#", undefined, undefined, vnode$$1.text, undefined, undefined)]; }
				}
				if (vnode$$1.children != null) {
					var children = vnode$$1.children;
					createNodes(element, children, 0, children.length, hooks, null, ns);
					setLateAttrs(vnode$$1);
				}
			}
			return element
		}
		function initComponent(vnode$$1, hooks) {
			var sentinel;
			if (typeof vnode$$1.tag.view === "function") {
				vnode$$1.state = Object.create(vnode$$1.tag);
				sentinel = vnode$$1.state.view;
				if (sentinel.$$reentrantLock$$ != null) { return $emptyFragment }
				sentinel.$$reentrantLock$$ = true;
			} else {
				vnode$$1.state = void 0;
				sentinel = vnode$$1.tag;
				if (sentinel.$$reentrantLock$$ != null) { return $emptyFragment }
				sentinel.$$reentrantLock$$ = true;
				vnode$$1.state = (vnode$$1.tag.prototype != null && typeof vnode$$1.tag.prototype.view === "function") ? new vnode$$1.tag(vnode$$1) : vnode$$1.tag(vnode$$1);
			}
			vnode$$1._state = vnode$$1.state;
			if (vnode$$1.attrs != null) { initLifecycle(vnode$$1.attrs, vnode$$1, hooks); }
			initLifecycle(vnode$$1._state, vnode$$1, hooks);
			vnode$$1.instance = vnode.normalize(vnode$$1._state.view.call(vnode$$1.state, vnode$$1));
			if (vnode$$1.instance === vnode$$1) { throw Error("A view cannot return the vnode it received as argument") }
			sentinel.$$reentrantLock$$ = null;
		}
		function createComponent(parent, vnode$$1, hooks, ns, nextSibling) {
			initComponent(vnode$$1, hooks);
			if (vnode$$1.instance != null) {
				var element = createNode(parent, vnode$$1.instance, hooks, ns, nextSibling);
				vnode$$1.dom = vnode$$1.instance.dom;
				vnode$$1.domSize = vnode$$1.dom != null ? vnode$$1.instance.domSize : 0;
				insertNode(parent, element, nextSibling);
				return element
			}
			else {
				vnode$$1.domSize = 0;
				return $emptyFragment
			}
		}

		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) { return }
			else if (old == null) { createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns); }
			else if (vnodes == null) { removeNodes(old, 0, old.length, vnodes); }
			else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false;
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null;
							break
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) { continue }
							else if (old[i] == null && vnodes[i] != null) { createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling)); }
							else if (vnodes[i] == null) { removeNodes(old, i, i + 1, vnodes); }
							else { updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns); }
						}
						return
					}
				}
				recycling = recycling || isRecyclable(old, vnodes);
				if (recycling) {
					var pool = old.pool;
					old = old.concat(old.pool);
				}

				var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map;
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart], v = vnodes[start];
					if (o === v && !recycling) { oldStart++, start++; }
					else if (o == null) { oldStart++; }
					else if (v == null) { start++; }
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling);
						oldStart++, start++;
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) { insertNode(parent, toFragment(o), nextSibling); }
					}
					else {
						var o = old[oldEnd];
						if (o === v && !recycling) { oldEnd--, start++; }
						else if (o == null) { oldEnd--; }
						else if (v == null) { start++; }
						else if (o.key === v.key) {
							var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling);
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
							if (recycling || start < end) { insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling)); }
							oldEnd--, start++;
						}
						else { break }
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd], v = vnodes[end];
					if (o === v && !recycling) { oldEnd--, end--; }
					else if (o == null) { oldEnd--; }
					else if (v == null) { end--; }
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling);
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns);
						if (recycling && o.tag === v.tag) { insertNode(parent, toFragment(o), nextSibling); }
						if (o.dom != null) { nextSibling = o.dom; }
						oldEnd--, end--;
					}
					else {
						if (!map) { map = getKeyMap(old, oldEnd); }
						if (v != null) {
							var oldIndex = map[v.key];
							if (oldIndex != null) {
								var movable = old[oldIndex];
								var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling);
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns);
								insertNode(parent, toFragment(movable), nextSibling);
								old[oldIndex].skip = true;
								if (movable.dom != null) { nextSibling = movable.dom; }
							}
							else {
								var dom = createNode(parent, v, hooks, ns, nextSibling);
								nextSibling = dom;
							}
						}
						end--;
					}
					if (end < start) { break }
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
				removeNodes(old, oldStart, oldEnd + 1, vnodes);
			}
		}
		function updateNode(parent, old, vnode$$1, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag, tag = vnode$$1.tag;
			if (oldTag === tag) {
				vnode$$1.state = old.state;
				vnode$$1._state = old._state;
				vnode$$1.events = old.events;
				if (!recycling && shouldNotUpdate(vnode$$1, old)) { return }
				if (typeof oldTag === "string") {
					if (vnode$$1.attrs != null) {
						if (recycling) {
							vnode$$1.state = {};
							initLifecycle(vnode$$1.attrs, vnode$$1, hooks);
						}
						else { updateLifecycle(vnode$$1.attrs, vnode$$1, hooks); }
					}
					switch (oldTag) {
						case "#": updateText(old, vnode$$1); break
						case "<": updateHTML(parent, old, vnode$$1, nextSibling); break
						case "[": updateFragment(parent, old, vnode$$1, recycling, hooks, nextSibling, ns); break
						default: updateElement(old, vnode$$1, recycling, hooks, ns);
					}
				}
				else { updateComponent(parent, old, vnode$$1, hooks, nextSibling, recycling, ns); }
			}
			else {
				removeNode(old, null);
				createNode(parent, vnode$$1, hooks, ns, nextSibling);
			}
		}
		function updateText(old, vnode$$1) {
			if (old.children.toString() !== vnode$$1.children.toString()) {
				old.dom.nodeValue = vnode$$1.children;
			}
			vnode$$1.dom = old.dom;
		}
		function updateHTML(parent, old, vnode$$1, nextSibling) {
			if (old.children !== vnode$$1.children) {
				toFragment(old);
				createHTML(parent, vnode$$1, nextSibling);
			}
			else { vnode$$1.dom = old.dom, vnode$$1.domSize = old.domSize; }
		}
		function updateFragment(parent, old, vnode$$1, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode$$1.children, recycling, hooks, nextSibling, ns);
			var domSize = 0, children = vnode$$1.children;
			vnode$$1.dom = null;
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i];
					if (child != null && child.dom != null) {
						if (vnode$$1.dom == null) { vnode$$1.dom = child.dom; }
						domSize += child.domSize || 1;
					}
				}
				if (domSize !== 1) { vnode$$1.domSize = domSize; }
			}
		}
		function updateElement(old, vnode$$1, recycling, hooks, ns) {
			var element = vnode$$1.dom = old.dom;
			ns = getNameSpace(vnode$$1) || ns;

			if (vnode$$1.tag === "textarea") {
				if (vnode$$1.attrs == null) { vnode$$1.attrs = {}; }
				if (vnode$$1.text != null) {
					vnode$$1.attrs.value = vnode$$1.text; //FIXME handle multiple children
					vnode$$1.text = undefined;
				}
			}
			updateAttrs(vnode$$1, old.attrs, vnode$$1.attrs, ns);
			if (vnode$$1.attrs != null && vnode$$1.attrs.contenteditable != null) {
				setContentEditable(vnode$$1);
			}
			else if (old.text != null && vnode$$1.text != null && vnode$$1.text !== "") {
				if (old.text.toString() !== vnode$$1.text.toString()) { old.dom.firstChild.nodeValue = vnode$$1.text; }
			}
			else {
				if (old.text != null) { old.children = [vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]; }
				if (vnode$$1.text != null) { vnode$$1.children = [vnode("#", undefined, undefined, vnode$$1.text, undefined, undefined)]; }
				updateNodes(element, old.children, vnode$$1.children, recycling, hooks, null, ns);
			}
		}
		function updateComponent(parent, old, vnode$$1, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode$$1, hooks);
			} else {
				vnode$$1.instance = vnode.normalize(vnode$$1._state.view.call(vnode$$1.state, vnode$$1));
				if (vnode$$1.instance === vnode$$1) { throw Error("A view cannot return the vnode it received as argument") }
				if (vnode$$1.attrs != null) { updateLifecycle(vnode$$1.attrs, vnode$$1, hooks); }
				updateLifecycle(vnode$$1._state, vnode$$1, hooks);
			}
			if (vnode$$1.instance != null) {
				if (old.instance == null) { createNode(parent, vnode$$1.instance, hooks, ns, nextSibling); }
				else { updateNode(parent, old.instance, vnode$$1.instance, hooks, nextSibling, recycling, ns); }
				vnode$$1.dom = vnode$$1.instance.dom;
				vnode$$1.domSize = vnode$$1.instance.domSize;
			}
			else if (old.instance != null) {
				removeNode(old.instance, null);
				vnode$$1.dom = undefined;
				vnode$$1.domSize = 0;
			}
			else {
				vnode$$1.dom = old.dom;
				vnode$$1.domSize = old.domSize;
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0;
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0;
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0;
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true
				}
			}
			return false
		}
		function getKeyMap(vnodes, end) {
			var map = {}, i = 0;
			for (var i = 0; i < end; i++) {
				var vnode$$1 = vnodes[i];
				if (vnode$$1 != null) {
					var key = vnode$$1.key;
					if (key != null) { map[key] = i; }
				}
			}
			return map
		}
		function toFragment(vnode$$1) {
			var count = vnode$$1.domSize;
			if (count != null || vnode$$1.dom == null) {
				var fragment = $doc.createDocumentFragment();
				if (count > 0) {
					var dom = vnode$$1.dom;
					while (--count) { fragment.appendChild(dom.nextSibling); }
					fragment.insertBefore(dom, fragment.firstChild);
				}
				return fragment
			}
			else { return vnode$$1.dom }
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) { return vnodes[i].dom }
			}
			return nextSibling
		}

		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) { parent.insertBefore(dom, nextSibling); }
			else { parent.appendChild(dom); }
		}

		function setContentEditable(vnode$$1) {
			var children = vnode$$1.children;
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children;
				if (vnode$$1.dom.innerHTML !== content) { vnode$$1.dom.innerHTML = content; }
			}
			else if (vnode$$1.text != null || children != null && children.length !== 0) { throw new Error("Child node of a contenteditable must be trusted") }
		}

		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode$$1 = vnodes[i];
				if (vnode$$1 != null) {
					if (vnode$$1.skip) { vnode$$1.skip = false; }
					else { removeNode(vnode$$1, context); }
				}
			}
		}
		function removeNode(vnode$$1, context) {
			var expected = 1, called = 0;
			if (vnode$$1.attrs && typeof vnode$$1.attrs.onbeforeremove === "function") {
				var result = vnode$$1.attrs.onbeforeremove.call(vnode$$1.state, vnode$$1);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			if (typeof vnode$$1.tag !== "string" && typeof vnode$$1._state.onbeforeremove === "function") {
				var result = vnode$$1._state.onbeforeremove.call(vnode$$1.state, vnode$$1);
				if (result != null && typeof result.then === "function") {
					expected++;
					result.then(continuation, continuation);
				}
			}
			continuation();
			function continuation() {
				if (++called === expected) {
					onremove(vnode$$1);
					if (vnode$$1.dom) {
						var count = vnode$$1.domSize || 1;
						if (count > 1) {
							var dom = vnode$$1.dom;
							while (--count) {
								removeNodeFromDOM(dom.nextSibling);
							}
						}
						removeNodeFromDOM(vnode$$1.dom);
						if (context != null && vnode$$1.domSize == null && !hasIntegrationMethods(vnode$$1.attrs) && typeof vnode$$1.tag === "string") { //TODO test custom elements
							if (!context.pool) { context.pool = [vnode$$1]; }
							else { context.pool.push(vnode$$1); }
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode;
			if (parent != null) { parent.removeChild(node); }
		}
		function onremove(vnode$$1) {
			if (vnode$$1.attrs && typeof vnode$$1.attrs.onremove === "function") { vnode$$1.attrs.onremove.call(vnode$$1.state, vnode$$1); }
			if (typeof vnode$$1.tag !== "string") {
				if (typeof vnode$$1._state.onremove === "function") { vnode$$1._state.onremove.call(vnode$$1.state, vnode$$1); }
				if (vnode$$1.instance != null) { onremove(vnode$$1.instance); }
			} else {
				var children = vnode$$1.children;
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i];
						if (child != null) { onremove(child); }
					}
				}
			}
		}

		//attrs
		function setAttrs(vnode$$1, attrs, ns) {
			for (var key in attrs) {
				setAttr(vnode$$1, key, null, attrs[key], ns);
			}
		}
		function setAttr(vnode$$1, key, old, value, ns) {
			var element = vnode$$1.dom;
			if (key === "key" || key === "is" || (old === value && !isFormAttribute(vnode$$1, key)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key)) { return }
			var nsLastIndex = key.indexOf(":");
			if (nsLastIndex > -1 && key.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(nsLastIndex + 1), value);
			}
			else if (key[0] === "o" && key[1] === "n" && typeof value === "function") { updateEvent(vnode$$1, key, value); }
			else if (key === "style") { updateStyle(element, old, value); }
			else if (key in element && !isAttribute(key) && ns === undefined && !isCustomElement(vnode$$1)) {
				if (key === "value") {
					var normalized = "" + value; // eslint-disable-line no-implicit-coercion
					//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
					if ((vnode$$1.tag === "input" || vnode$$1.tag === "textarea") && vnode$$1.dom.value === normalized && vnode$$1.dom === $doc.activeElement) { return }
					//setting select[value] to same value while having select open blinks select dropdown in Chrome
					if (vnode$$1.tag === "select") {
						if (value === null) {
							if (vnode$$1.dom.selectedIndex === -1 && vnode$$1.dom === $doc.activeElement) { return }
						} else {
							if (old !== null && vnode$$1.dom.value === normalized && vnode$$1.dom === $doc.activeElement) { return }
						}
					}
					//setting option[value] to same value while having select open blinks select dropdown in Chrome
					if (vnode$$1.tag === "option" && old != null && vnode$$1.dom.value === normalized) { return }
				}
				// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
				if (vnode$$1.tag === "input" && key === "type") {
					element.setAttribute(key, value);
					return
				}
				element[key] = value;
			}
			else {
				if (typeof value === "boolean") {
					if (value) { element.setAttribute(key, ""); }
					else { element.removeAttribute(key); }
				}
				else { element.setAttribute(key === "className" ? "class" : key, value); }
			}
		}
		function setLateAttrs(vnode$$1) {
			var attrs = vnode$$1.attrs;
			if (vnode$$1.tag === "select" && attrs != null) {
				if ("value" in attrs) { setAttr(vnode$$1, "value", null, attrs.value, undefined); }
				if ("selectedIndex" in attrs) { setAttr(vnode$$1, "selectedIndex", null, attrs.selectedIndex, undefined); }
			}
		}
		function updateAttrs(vnode$$1, old, attrs, ns) {
			if (attrs != null) {
				for (var key in attrs) {
					setAttr(vnode$$1, key, old && old[key], attrs[key], ns);
				}
			}
			if (old != null) {
				for (var key in old) {
					if (attrs == null || !(key in attrs)) {
						if (key === "className") { key = "class"; }
						if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) { updateEvent(vnode$$1, key, undefined); }
						else if (key !== "key") { vnode$$1.dom.removeAttribute(key); }
					}
				}
			}
		}
		function isFormAttribute(vnode$$1, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode$$1.dom === $doc.activeElement
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
		}
		function isCustomElement(vnode$$1){
			return vnode$$1.attrs.is || vnode$$1.tag.indexOf("-") > -1
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
		}

		//style
		function updateStyle(element, old, style) {
			if (old === style) { element.style.cssText = "", old = null; }
			if (style == null) { element.style.cssText = ""; }
			else if (typeof style === "string") { element.style.cssText = style; }
			else {
				if (typeof old === "string") { element.style.cssText = ""; }
				for (var key in style) {
					element.style[key] = style[key];
				}
				if (old != null && typeof old !== "string") {
					for (var key in old) {
						if (!(key in style)) { element.style[key] = ""; }
					}
				}
			}
		}

		//event
		function updateEvent(vnode$$1, key, value) {
			var element = vnode$$1.dom;
			var callback = typeof onevent !== "function" ? value : function(e) {
				var result = value.call(element, e);
				onevent.call(element, e);
				return result
			};
			if (key in element) { element[key] = typeof value === "function" ? callback : null; }
			else {
				var eventName = key.slice(2);
				if (vnode$$1.events === undefined) { vnode$$1.events = {}; }
				if (vnode$$1.events[key] === callback) { return }
				if (vnode$$1.events[key] != null) { element.removeEventListener(eventName, vnode$$1.events[key], false); }
				if (typeof value === "function") {
					vnode$$1.events[key] = callback;
					element.addEventListener(eventName, vnode$$1.events[key], false);
				}
			}
		}

		//lifecycle
		function initLifecycle(source, vnode$$1, hooks) {
			if (typeof source.oninit === "function") { source.oninit.call(vnode$$1.state, vnode$$1); }
			if (typeof source.oncreate === "function") { hooks.push(source.oncreate.bind(vnode$$1.state, vnode$$1)); }
		}
		function updateLifecycle(source, vnode$$1, hooks) {
			if (typeof source.onupdate === "function") { hooks.push(source.onupdate.bind(vnode$$1.state, vnode$$1)); }
		}
		function shouldNotUpdate(vnode$$1, old) {
			var forceVnodeUpdate, forceComponentUpdate;
			if (vnode$$1.attrs != null && typeof vnode$$1.attrs.onbeforeupdate === "function") { forceVnodeUpdate = vnode$$1.attrs.onbeforeupdate.call(vnode$$1.state, vnode$$1, old); }
			if (typeof vnode$$1.tag !== "string" && typeof vnode$$1._state.onbeforeupdate === "function") { forceComponentUpdate = vnode$$1._state.onbeforeupdate.call(vnode$$1.state, vnode$$1, old); }
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode$$1.dom = old.dom;
				vnode$$1.domSize = old.domSize;
				vnode$$1.instance = old.instance;
				return true
			}
			return false
		}

		function render(dom, vnodes) {
			if (!dom) { throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.") }
			var hooks = [];
			var active = $doc.activeElement;
			var namespace = dom.namespaceURI;

			// First time rendering into a node clears it out
			if (dom.vnodes == null) { dom.textContent = ""; }

			if (!Array.isArray(vnodes)) { vnodes = [vnodes]; }
			updateNodes(dom, dom.vnodes, vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace);
			dom.vnodes = vnodes;
			// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
			if (active != null && $doc.activeElement !== active) { active.focus(); }
			for (var i = 0; i < hooks.length; i++) { hooks[i](); }
		}

		return {render: render, setEventCallback: setEventCallback}
	};

	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16;
		var last = 0, pending = null;
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout;
		return function() {
			var now = Date.now();
			if (last === 0 || now - last >= time) {
				last = now;
				callback();
			}
			else if (pending === null) {
				pending = timeout(function() {
					pending = null;
					callback();
					last = Date.now();
				}, time - (now - last));
			}
		}
	}

	var redraw = function($window) {
		var renderService = render($window);
		renderService.setEventCallback(function(e) {
			if (e.redraw === false) { e.redraw = undefined; }
			else { redraw(); }
		});

		var callbacks = [];
		function subscribe(key, callback) {
			unsubscribe(key);
			callbacks.push(key, throttle(callback));
		}
		function unsubscribe(key) {
			var index = callbacks.indexOf(key);
			if (index > -1) { callbacks.splice(index, 2); }
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]();
			}
		}
		return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
	};

	var redraw$1 = redraw(window);

	var mount = function(redrawService) {
		return function(root, component) {
			if (component === null) {
				redrawService.render(root, []);
				redrawService.unsubscribe(root);
				return
			}
			
			if (component.view == null && typeof component !== "function") { throw new Error("m.mount(element, component) expects a component, not a vnode") }
			
			var run = function() {
				redrawService.render(root, vnode(component));
			};
			redrawService.subscribe(root, run);
			redrawService.redraw();
		}
	};

	var mount$1 = mount(redraw$1);

	var parse = function(string) {
		if (string === "" || string == null) { return {} }
		if (string.charAt(0) === "?") { string = string.slice(1); }

		var entries = string.split("&"), data = {}, counters = {};
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=");
			var key = decodeURIComponent(entry[0]);
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";

			if (value === "true") { value = true; }
			else if (value === "false") { value = false; }

			var levels = key.split(/\]\[?|\[/);
			var cursor = data;
			if (key.indexOf("[") > -1) { levels.pop(); }
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j], nextLevel = levels[j + 1];
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
				var isValue = j === levels.length - 1;
				if (level === "") {
					var key = levels.slice(0, j).join();
					if (counters[key] == null) { counters[key] = 0; }
					level = counters[key]++;
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {};
				}
				cursor = cursor[level];
			}
		}
		return data
	};

	var router = function($window) {
		var supportsPushState = typeof $window.history.pushState === "function";
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;

		function normalize(fragment) {
			var data = $window.location[fragment].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent);
			if (fragment === "pathname" && data[0] !== "/") { data = "/" + data; }
			return data
		}

		var asyncId;
		function debounceAsync(callback) {
			return function() {
				if (asyncId != null) { return }
				asyncId = callAsync(function() {
					asyncId = null;
					callback();
				});
			}
		}

		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?");
			var hashIndex = path.indexOf("#");
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length;
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length;
				var queryParams = parse(path.slice(queryIndex + 1, queryEnd));
				for (var key in queryParams) { queryData[key] = queryParams[key]; }
			}
			if (hashIndex > -1) {
				var hashParams = parse(path.slice(hashIndex + 1));
				for (var key in hashParams) { hashData[key] = hashParams[key]; }
			}
			return path.slice(0, pathEnd)
		}

		var router = {prefix: "#!"};
		router.getPath = function() {
			var type = router.prefix.charAt(0);
			switch (type) {
				case "#": return normalize("hash").slice(router.prefix.length)
				case "?": return normalize("search").slice(router.prefix.length) + normalize("hash")
				default: return normalize("pathname").slice(router.prefix.length) + normalize("search") + normalize("hash")
			}
		};
		router.setPath = function(path, data, options) {
			var queryData = {}, hashData = {};
			path = parsePath(path, queryData, hashData);
			if (data != null) {
				for (var key in data) { queryData[key] = data[key]; }
				path = path.replace(/:([^\/]+)/g, function(match, token) {
					delete queryData[token];
					return data[token]
				});
			}

			var query = build(queryData);
			if (query) { path += "?" + query; }

			var hash = build(hashData);
			if (hash) { path += "#" + hash; }

			if (supportsPushState) {
				var state = options ? options.state : null;
				var title = options ? options.title : null;
				$window.onpopstate();
				if (options && options.replace) { $window.history.replaceState(state, title, router.prefix + path); }
				else { $window.history.pushState(state, title, router.prefix + path); }
			}
			else { $window.location.href = router.prefix + path; }
		};
		router.defineRoutes = function(routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath();
				var params = {};
				var pathname = parsePath(path, params, params);

				var state = $window.history.state;
				if (state != null) {
					for (var k in state) { params[k] = state[k]; }
				}
				for (var route in routes) {
					var matcher = new RegExp("^" + route.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");

					if (matcher.test(pathname)) {
						pathname.replace(matcher, function() {
							var keys = route.match(/:[^\/]+/g) || [];
							var values = [].slice.call(arguments, 1, -2);
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
							}
							resolve(routes[route], params, path, route);
						});
						return
					}
				}

				reject(path, params);
			}

			if (supportsPushState) { $window.onpopstate = debounceAsync(resolveRoute); }
			else if (router.prefix.charAt(0) === "#") { $window.onhashchange = resolveRoute; }
			resolveRoute();
		};

		return router
	};

	var router$1 = function($window, redrawService) {
		var routeService = router($window);

		var identity = function(v) {return v};
		var render, component, attrs, currentPath, lastUpdate;
		var route = function(root, defaultRoute, routes) {
			if (root == null) { throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined") }
			var run = function() {
				if (render != null) { redrawService.render(root, render(vnode(component, attrs.key, attrs))); }
			};
			var bail = function(path) {
				if (path !== defaultRoute) { routeService.setPath(defaultRoute, null, {replace: true}); }
				else { throw new Error("Could not resolve default route " + defaultRoute) }
			};
			routeService.defineRoutes(routes, function(payload, params, path) {
				var update = lastUpdate = function(routeResolver, comp) {
					if (update !== lastUpdate) { return }
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div";
					attrs = params, currentPath = path, lastUpdate = null;
					render = (routeResolver.render || identity).bind(routeResolver);
					run();
				};
				if (payload.view || typeof payload === "function") { update({}, payload); }
				else {
					if (payload.onmatch) {
						promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
							update(payload, resolved);
						}, bail);
					}
					else { update(payload, "div"); }
				}
			}, bail);
			redrawService.subscribe(root, run);
		};
		route.set = function(path, data, options) {
			if (lastUpdate != null) {
				options = options || {};
				options.replace = true;
			}
			lastUpdate = null;
			routeService.setPath(path, data, options);
		};
		route.get = function() {return currentPath};
		route.prefix = function(prefix) {routeService.prefix = prefix;};
		route.link = function(vnode$$1) {
			vnode$$1.dom.setAttribute("href", routeService.prefix + vnode$$1.attrs.href);
			vnode$$1.dom.onclick = function(e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) { return }
				e.preventDefault();
				e.redraw = false;
				var href = this.getAttribute("href");
				if (href.indexOf(routeService.prefix) === 0) { href = href.slice(routeService.prefix.length); }
				route.set(href, undefined, undefined);
			};
		};
		route.param = function(key) {
			if(typeof attrs !== "undefined" && typeof key !== "undefined") { return attrs[key] }
			return attrs
		};

		return route
	};

	var route = router$1(window, redraw$1);

	var withAttr = function(attrName, callback, context) {
		return function(e) {
			callback.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName));
		}
	};

	var render$1 = render(window);

	request$1.setCompletionCallback(redraw$1.redraw);

	hyperscript_1$1.mount = mount$1;
	hyperscript_1$1.route = route;
	hyperscript_1$1.withAttr = withAttr;
	hyperscript_1$1.render = render$1.render;
	hyperscript_1$1.redraw = redraw$1.redraw;
	hyperscript_1$1.request = request$1.request;
	hyperscript_1$1.jsonp = request$1.jsonp;
	hyperscript_1$1.parseQueryString = parse;
	hyperscript_1$1.buildQueryString = build;
	hyperscript_1$1.version = "bleeding-edge";
	hyperscript_1$1.vnode = vnode;

	var mithril = hyperscript_1$1;

	/**
	 * Template for initial documents
	 */
	var Documents = {
	    new: {
	        title: 'Untitled document',
	        code: '# Hello world\n\n```javascript\nfunction() {\n    console.log("hello world");\n}\n```\n\n### Description\n\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi.',
	    }
	};

	var documents = Documents;

	var CONFIG$1 = {
	    Documents: documents
	};

	/**
	 * Helper fuction to call when device or dom are ready
	 * @param  {Function} func Function to call when the device or dom are ready
	 */
	var Ready = function (func) {
	    var event = /https?:\/\//.test(window.document.URL) ? 'DOMContentLoaded' : 'deviceready';
	    window.document.addEventListener(event, func, false);
	};

	/**
	 * Helper function to change the title of the page
	 * @param  {String} title New title
	 */
	var Title = function (title) {
	    window.document.title = title;
	    var titleTag = window.document.getElementsByTagName('title')[0];
	    titleTag.innerHtml = title;
	};

	var HELPER$1 = {
	    Ready: Ready,
	    Title: Title
	};

	var loc = window.location;

	var Api = {
	    baseUrl: loc.origin || loc.protocol + '//' + loc.hostname + (loc.port ? (':' + loc.port) : ''),
	    request: function request(method) {
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        var data = undefined;
	        if (typeof args[args.length - 1] === 'object') {
	            data = args.pop();
	        }

	        return m.request({
	            method: method,
	            url: ((Api.baseUrl) + "/" + (args.join('/'))),
	            data: data,
	            body: data
	        })
	            .catch(function (error) {
	                COMPONENT.Notification.open({
	                    color: 'danger',
	                    content: SERVICE.Lang(error.message)
	                });
	                throw error;
	            });
	    },
	};

	'get|post|put|delete'.split('|').forEach(function (method) {
	    Api[method] = function () {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        args.unshift(method);
	        return Api.request.apply(Api, args);
	    };
	});

	var marked = createCommonjsModule(function (module, exports) {
	(function(root) {

	/**
	 * Block-Level Grammar
	 */

	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
	  table: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  paragraph: /^([^\n]+(?:\n?(?!hr|heading|lheading| {0,3}>|tag)[^\n]+)+)/,
	  text: /^[^\n]+/
	};

	block._label = /(?:\\[\[\]]|[^\[\]])+/;
	block._title = /(?:"(?:\\"|[^"]|"[^"\n]*")*"|'\n?(?:[^'\n]+\n?)*'|\([^()]*\))/;
	block.def = edit(block.def)
	  .replace('label', block._label)
	  .replace('title', block._title)
	  .getRegex();

	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = edit(block.item, 'gm')
	  .replace(/bull/g, block.bullet)
	  .getRegex();

	block.list = edit(block.list)
	  .replace(/bull/g, block.bullet)
	  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
	  .replace('def', '\\n+(?=' + block.def.source + ')')
	  .getRegex();

	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b';

	block.html = edit(block.html)
	  .replace('comment', /<!--[\s\S]*?-->/)
	  .replace('closed', /<(tag)[\s\S]+?<\/\1>/)
	  .replace('closing', /<tag(?:"[^"]*"|'[^']*'|\s[^'"\/>\s]*)*?\/?>/)
	  .replace(/tag/g, block._tag)
	  .getRegex();

	block.paragraph = edit(block.paragraph)
	  .replace('hr', block.hr)
	  .replace('heading', block.heading)
	  .replace('lheading', block.lheading)
	  .replace('tag', '<' + block._tag)
	  .getRegex();

	block.blockquote = edit(block.blockquote)
	  .replace('paragraph', block.paragraph)
	  .getRegex();

	/**
	 * Normal Block Grammar
	 */

	block.normal = merge({}, block);

	/**
	 * GFM Block Grammar
	 */

	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});

	block.gfm.paragraph = edit(block.paragraph)
	  .replace('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  .getRegex();

	/**
	 * GFM + Tables Block Grammar
	 */

	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});

	/**
	 * Block Lexer
	 */

	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;

	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}

	/**
	 * Expose Block Rules
	 */

	Lexer.rules = block;

	/**
	 * Static Lex Method
	 */

	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};

	/**
	 * Preprocessing
	 */

	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');

	  return this.token(src, true);
	};

	/**
	 * Lexing
	 */

	Lexer.prototype.token = function(src, top) {
	  var this$1 = this;

	  src = src.replace(/^ +$/gm, '');
	  var next,
	      loose,
	      cap,
	      bull,
	      b,
	      item,
	      space,
	      i,
	      tag,
	      l,
	      isordered;

	  while (src) {
	    // newline
	    if (cap = this$1.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this$1.tokens.push({
	          type: 'space'
	        });
	      }
	    }

	    // code
	    if (cap = this$1.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this$1.tokens.push({
	        type: 'code',
	        text: !this$1.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }

	    // fences (gfm)
	    if (cap = this$1.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }

	    // heading
	    if (cap = this$1.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }

	    // table no leading pipe (gfm)
	    if (top && (cap = this$1.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);

	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };

	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }

	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }

	      this$1.tokens.push(item);

	      continue;
	    }

	    // hr
	    if (cap = this$1.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }

	    // blockquote
	    if (cap = this$1.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);

	      this$1.tokens.push({
	        type: 'blockquote_start'
	      });

	      cap = cap[0].replace(/^ *> ?/gm, '');

	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this$1.token(cap, top);

	      this$1.tokens.push({
	        type: 'blockquote_end'
	      });

	      continue;
	    }

	    // list
	    if (cap = this$1.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	      isordered = bull.length > 1;

	      this$1.tokens.push({
	        type: 'list_start',
	        ordered: isordered,
	        start: isordered ? +bull : ''
	      });

	      // Get each top-level item.
	      cap = cap[0].match(this$1.rules.item);

	      next = false;
	      l = cap.length;
	      i = 0;

	      for (; i < l; i++) {
	        item = cap[i];

	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this$1.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }

	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this$1.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }

	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) { loose = next; }
	        }

	        this$1.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });

	        // Recurse.
	        this$1.token(item, false);

	        this$1.tokens.push({
	          type: 'list_item_end'
	        });
	      }

	      this$1.tokens.push({
	        type: 'list_end'
	      });

	      continue;
	    }

	    // html
	    if (cap = this$1.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: this$1.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this$1.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }

	    // def
	    if (top && (cap = this$1.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      if (cap[3]) { cap[3] = cap[3].substring(1, cap[3].length - 1); }
	      tag = cap[1].toLowerCase();
	      if (!this$1.tokens.links[tag]) {
	        this$1.tokens.links[tag] = {
	          href: cap[2],
	          title: cap[3]
	        };
	      }
	      continue;
	    }

	    // table (gfm)
	    if (top && (cap = this$1.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);

	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };

	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }

	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }

	      this$1.tokens.push(item);

	      continue;
	    }

	    // lheading
	    if (cap = this$1.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }

	    // top-level paragraph
	    if (top && (cap = this$1.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }

	    // text
	    if (cap = this$1.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this$1.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }

	    if (src) {
	      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }

	  return this.tokens;
	};

	/**
	 * Inline-Level Grammar
	 */

	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?[a-zA-Z0-9\-]+(?:"[^"]*"|'[^']*'|\s[^<'">\/\s]*)*?\/?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^_([^\s_](?:[^_]|__)+?[^\s_])_\b|^\*((?:\*\*|[^*])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/
	};

	inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
	inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;

	inline.autolink = edit(inline.autolink)
	  .replace('scheme', inline._scheme)
	  .replace('email', inline._email)
	  .getRegex();

	inline._inside = /(?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

	inline.link = edit(inline.link)
	  .replace('inside', inline._inside)
	  .replace('href', inline._href)
	  .getRegex();

	inline.reflink = edit(inline.reflink)
	  .replace('inside', inline._inside)
	  .getRegex();

	/**
	 * Normal Inline Grammar
	 */

	inline.normal = merge({}, inline);

	/**
	 * Pedantic Inline Grammar
	 */

	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});

	/**
	 * GFM Inline Grammar
	 */

	inline.gfm = merge({}, inline.normal, {
	  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
	  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)
	    .replace('email', inline._email)
	    .getRegex(),
	  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: edit(inline.text)
	    .replace(']|', '~]|')
	    .replace('|', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|')
	    .getRegex()
	});

	/**
	 * GFM + Line Breaks Inline Grammar
	 */

	inline.breaks = merge({}, inline.gfm, {
	  br: edit(inline.br).replace('{2,}', '*').getRegex(),
	  text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()
	});

	/**
	 * Inline Lexer & Compiler
	 */

	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer();
	  this.renderer.options = this.options;

	  if (!this.links) {
	    throw new Error('Tokens array requires a `links` property.');
	  }

	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}

	/**
	 * Expose Inline Rules
	 */

	InlineLexer.rules = inline;

	/**
	 * Static Lexing/Compiling Method
	 */

	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};

	/**
	 * Lexing/Compiling
	 */

	InlineLexer.prototype.output = function(src) {
	  var this$1 = this;

	  var out = '',
	      link,
	      text,
	      href,
	      cap;

	  while (src) {
	    // escape
	    if (cap = this$1.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }

	    // autolink
	    if (cap = this$1.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = escape(this$1.mangle(cap[1]));
	        href = 'mailto:' + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this$1.renderer.link(href, null, text);
	      continue;
	    }

	    // url (gfm)
	    if (!this$1.inLink && (cap = this$1.rules.url.exec(src))) {
	      cap[0] = this$1.rules._backpedal.exec(cap[0])[0];
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = escape(cap[0]);
	        href = 'mailto:' + text;
	      } else {
	        text = escape(cap[0]);
	        if (cap[1] === 'www.') {
	          href = 'http://' + text;
	        } else {
	          href = text;
	        }
	      }
	      out += this$1.renderer.link(href, null, text);
	      continue;
	    }

	    // tag
	    if (cap = this$1.rules.tag.exec(src)) {
	      if (!this$1.inLink && /^<a /i.test(cap[0])) {
	        this$1.inLink = true;
	      } else if (this$1.inLink && /^<\/a>/i.test(cap[0])) {
	        this$1.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this$1.options.sanitize
	        ? this$1.options.sanitizer
	          ? this$1.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0];
	      continue;
	    }

	    // link
	    if (cap = this$1.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this$1.inLink = true;
	      out += this$1.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this$1.inLink = false;
	      continue;
	    }

	    // reflink, nolink
	    if ((cap = this$1.rules.reflink.exec(src))
	        || (cap = this$1.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this$1.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this$1.inLink = true;
	      out += this$1.outputLink(cap, link);
	      this$1.inLink = false;
	      continue;
	    }

	    // strong
	    if (cap = this$1.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this$1.renderer.strong(this$1.output(cap[2] || cap[1]));
	      continue;
	    }

	    // em
	    if (cap = this$1.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this$1.renderer.em(this$1.output(cap[2] || cap[1]));
	      continue;
	    }

	    // code
	    if (cap = this$1.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this$1.renderer.codespan(escape(cap[2].trim(), true));
	      continue;
	    }

	    // br
	    if (cap = this$1.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this$1.renderer.br();
	      continue;
	    }

	    // del (gfm)
	    if (cap = this$1.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this$1.renderer.del(this$1.output(cap[1]));
	      continue;
	    }

	    // text
	    if (cap = this$1.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this$1.renderer.text(escape(this$1.smartypants(cap[0])));
	      continue;
	    }

	    if (src) {
	      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }

	  return out;
	};

	/**
	 * Compile Link
	 */

	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href),
	      title = link.title ? escape(link.title) : null;

	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};

	/**
	 * Smartypants Transformations
	 */

	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) { return text; }
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};

	/**
	 * Mangle Links
	 */

	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) { return text; }
	  var out = '',
	      l = text.length,
	      i = 0,
	      ch;

	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }

	  return out;
	};

	/**
	 * Renderer
	 */

	function Renderer(options) {
	  this.options = options || {};
	}

	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }

	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }

	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};

	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};

	Renderer.prototype.html = function(html) {
	  return html;
	};

	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};

	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};

	Renderer.prototype.list = function(body, ordered, start) {
	  var type = ordered ? 'ol' : 'ul',
	      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
	  return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
	};

	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};

	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};

	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};

	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};

	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};

	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};

	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};

	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};

	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};

	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};

	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return text;
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
	      return text;
	    }
	  }
	  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
	    href = resolveUrl(this.options.baseUrl, href);
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};

	Renderer.prototype.image = function(href, title, text) {
	  if (this.options.baseUrl && !originIndependentUrl.test(href)) {
	    href = resolveUrl(this.options.baseUrl, href);
	  }
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};

	Renderer.prototype.text = function(text) {
	  return text;
	};

	/**
	 * TextRenderer
	 * returns only the textual part of the token
	 */

	function TextRenderer() {}

	// no need for block level renderers

	TextRenderer.prototype.strong =
	TextRenderer.prototype.em =
	TextRenderer.prototype.codespan =
	TextRenderer.prototype.del =
	TextRenderer.prototype.text = function (text) {
	  return text;
	};

	TextRenderer.prototype.link =
	TextRenderer.prototype.image = function(href, title, text) {
	  return '' + text;
	};

	TextRenderer.prototype.br = function() {
	  return '';
	};

	/**
	 * Parsing & Compiling
	 */

	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer();
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}

	/**
	 * Static Parse Method
	 */

	Parser.parse = function(src, options) {
	  var parser = new Parser(options);
	  return parser.parse(src);
	};

	/**
	 * Parse Loop
	 */

	Parser.prototype.parse = function(src) {
	  var this$1 = this;

	  this.inline = new InlineLexer(src.links, this.options);
	  // use an InlineLexer with a TextRenderer to extract pure text
	  this.inlineText = new InlineLexer(
	    src.links,
	    merge({}, this.options, {renderer: new TextRenderer()})
	  );
	  this.tokens = src.reverse();

	  var out = '';
	  while (this.next()) {
	    out += this$1.tok();
	  }

	  return out;
	};

	/**
	 * Next Token
	 */

	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};

	/**
	 * Preview Next Token
	 */

	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};

	/**
	 * Parse Text Tokens
	 */

	Parser.prototype.parseText = function() {
	  var this$1 = this;

	  var body = this.token.text;

	  while (this.peek().type === 'text') {
	    body += '\n' + this$1.next().text;
	  }

	  return this.inline.output(body);
	};

	/**
	 * Parse Current Token
	 */

	Parser.prototype.tok = function() {
	  var this$1 = this;

	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        unescape(this.inlineText.output(this.token.text)));
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = '',
	          body = '',
	          i,
	          row,
	          cell,
	          j;

	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        cell += this$1.renderer.tablecell(
	          this$1.inline.output(this$1.token.header[i]),
	          { header: true, align: this$1.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);

	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this$1.token.cells[i];

	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this$1.renderer.tablecell(
	            this$1.inline.output(row[j]),
	            { header: false, align: this$1.token.align[j] }
	          );
	        }

	        body += this$1.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      body = '';

	      while (this.next().type !== 'blockquote_end') {
	        body += this$1.tok();
	      }

	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      body = '';
	      var ordered = this.token.ordered,
	          start = this.token.start;

	      while (this.next().type !== 'list_end') {
	        body += this$1.tok();
	      }

	      return this.renderer.list(body, ordered, start);
	    }
	    case 'list_item_start': {
	      body = '';

	      while (this.next().type !== 'list_item_end') {
	        body += this$1.token.type === 'text'
	          ? this$1.parseText()
	          : this$1.tok();
	      }

	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      body = '';

	      while (this.next().type !== 'list_item_end') {
	        body += this$1.tok();
	      }

	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};

	/**
	 * Helpers
	 */

	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}

	function unescape(html) {
	  // explicitly match decimal, hex, and named HTML entities
	  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') { return ':'; }
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}

	function edit(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return {
	    replace: function(name, val) {
	      val = val.source || val;
	      val = val.replace(/(^|[^\[])\^/g, '$1');
	      regex = regex.replace(name, val);
	      return this;
	    },
	    getRegex: function() {
	      return new RegExp(regex, opt);
	    }
	  };
	}

	function resolveUrl(base, href) {
	  if (!baseUrls[' ' + base]) {
	    // we can ignore everything in base after the last slash of its path component,
	    // but we might need to add _that_
	    // https://tools.ietf.org/html/rfc3986#section-3
	    if (/^[^:]+:\/*[^/]*$/.test(base)) {
	      baseUrls[' ' + base] = base + '/';
	    } else {
	      baseUrls[' ' + base] = base.replace(/[^/]*$/, '');
	    }
	  }
	  base = baseUrls[' ' + base];

	  if (href.slice(0, 2) === '//') {
	    return base.replace(/:[\s\S]*/, ':') + href;
	  } else if (href.charAt(0) === '/') {
	    return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
	  } else {
	    return base + href;
	  }
	}
	var baseUrls = {};
	var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

	function noop() {}
	noop.exec = noop;

	function merge(obj) {
	  var arguments$1 = arguments;

	  var i = 1,
	      target,
	      key;

	  for (; i < arguments.length; i++) {
	    target = arguments$1[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }

	  return obj;
	}

	/**
	 * Marked
	 */

	function marked(src, opt, callback) {
	  // throw error in case of non string input
	  if (typeof src === 'undefined' || src === null) {
	    throw new Error('marked(): input parameter is undefined or null');
	  }
	  if (typeof src !== 'string') {
	    throw new Error('marked(): input parameter is of type '
	      + Object.prototype.toString.call(src) + ', string expected');
	  }

	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }

	    opt = merge({}, marked.defaults, opt || {});

	    var highlight = opt.highlight,
	        tokens,
	        pending,
	        i = 0;

	    try {
	      tokens = Lexer.lex(src, opt);
	    } catch (e) {
	      return callback(e);
	    }

	    pending = tokens.length;

	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }

	      var out;

	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }

	      opt.highlight = highlight;

	      return err
	        ? callback(err)
	        : callback(null, out);
	    };

	    if (!highlight || highlight.length < 3) {
	      return done();
	    }

	    delete opt.highlight;

	    if (!pending) { return done(); }

	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) { return done(err); }
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }

	    return;
	  }
	  try {
	    if (opt) { opt = merge({}, marked.defaults, opt); }
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occurred:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}

	/**
	 * Options
	 */

	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};

	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer(),
	  xhtml: false,
	  baseUrl: null
	};

	/**
	 * Expose
	 */

	marked.Parser = Parser;
	marked.parser = Parser.parse;

	marked.Renderer = Renderer;
	marked.TextRenderer = TextRenderer;

	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;

	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;

	marked.parse = marked;

	{
	  module.exports = marked;
	}
	})(commonjsGlobal || (typeof window !== 'undefined' ? window : commonjsGlobal));
	});

	var marked$1 = marked;

	var Markdown = {
	    render: function render(code) {
	        return marked$1(code);
	    }
	};

	var Service = {
	    isValid: function isValid(document, checkCode) {
	        if ( document === void 0 ) document = {};
	        if ( checkCode === void 0 ) checkCode = true;

	        var isValid = typeof document === 'object'
	            && !Array.isArray(document)
	            && Object.keys(document).length > 0
	            && typeof document.title === 'string'
	            && (checkCode ? typeof document.code === 'string' : true);

	        if (isValid) {
	            return Promise.resolve();
	        }

	        COMPONENT.Notification.open({
	            color: 'danger',
	            content: SERVICE.Lang('document.error.invalid')
	        });

	        return Promise.reject({
	            status: 'error',
	            message: SERVICE.Lang('document.error.invalid'),
	            data: document
	        });
	    },
	    new: function new$1() {
	        var doc = Object.assign({}, CONFIG.Documents.new);
	        doc.code = '';
	        doc.isNew = true;
	        return doc;
	    },
	    add: function add(document) {
	        return Service
	            .isValid(document)
	            .then(function () {
	                var doc = Object.assign({
	                    title: document.title.trim() || '',
	                    code: document.code.trim() || ''
	                }, document);
	                return SERVICE.Api.post('api', document);
	            });
	    },
	    find: function find(options) {
	        if ( options === void 0 ) options = {};

	        return SERVICE.Api.get('api');
	    },
	    get: function get(id) {
	        return SERVICE.Api.get('api', id);
	    },
	    save: function save(document) {
	        if ( document === void 0 ) document = {};

	        document.isSaving = true;
	        return Service
	            .isValid(document)
	            .then(function () {
	                if (!document.isModified) {
	                    return document;
	                }

	                var query;

	                if (document.isNew && document.$loki === undefined) {
	                    query = Service.add(document);
	                }

	                if (!document.isNew && document.$loki !== undefined) {
	                    query = SERVICE.Api.put('api', document);
	                }

	                return query
	                    .then(function (response) {
	                        var doc = response.data;
	                        Object.assign(document, doc);
	                        document.isModified = false;
	                        document.isSaving = false;
	                        document.isNew = false;
	                        return document;
	                    });
	            })
	            .catch(function (err) {
	                if (err.message === 'document.error.validation') {
	                    COMPONENT.Modal.open({
	                        header: m('h1', SERVICE.Lang('document.error.validation')),
	                        content: [
	                            m('ul[data-list="two-line"][data-font="danger"]', Object.keys(err.errors).map(function (errorName) {
	                                var e = err.errors[errorName];
	                                var translationCode = e.message;
	                                if (e.arg) {
	                                    translationCode += '_' + e.arg;
	                                }
	                                return m('li', [
	                                    m('span.wrap', e.path + ': ' + SERVICE.Lang(translationCode))
	                                ]);
	                            }))
	                        ],
	                        footer: [
	                            m('nav', [
	                                m('button[data-button="default"]', {
	                                    onclick: function onclick(e) {
	                                        COMPONENT.Modal.close(e);
	                                        e.preventDefault();
	                                    }
	                                }, SERVICE.Lang('actions.close'))
	                            ])
	                        ]
	                    });
	                }
	                document.isModified = true;
	                document.isSaving = false;
	            });
	    },
	    delete: function delete$1(document) {
	        if ( document === void 0 ) document = {};

	        document.isSaving = true;
	        return Service
	            .isValid(document, false)
	            .then(function () {

	                if (document.isNew && document.$loki === undefined) {
	                    return Promise.resolve();
	                }

	                if (!document.isNew && document.$loki !== undefined) {
	                    return SERVICE.Api
	                        .delete('api', document)
	                        .then(function (response) {
	                            COMPONENT.Notification.open({
	                                color: 'success',
	                                content: SERVICE.Lang(response.message)
	                            });
	                        });
	                }
	            });
	    }
	};

	var timeago_min = createCommonjsModule(function (module) {
	!function(t,e){"object"=='object'&&module.exports?(module.exports=e(), module.exports.default=module.exports):t.timeago=e();}("undefined"!=typeof window?window:commonjsGlobal,function(){function t(t){return t instanceof Date?t:isNaN(t)?/^\d+$/.test(t)?new Date(e(t)):(t=(t||"").trim().replace(/\.\d+/,"").replace(/-/,"/").replace(/-/,"/").replace(/(\d)T(\d)/,"$1 $2").replace(/Z/," UTC").replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2"), new Date(t)):new Date(e(t))}function e(t){return parseInt(t)}function n(t,n,r){n=l[n]?n:l[r]?r:"en";for(var o=0,i=t<0?1:0,a=t=Math.abs(t);t>=p[o]&&o<h;o++){ t/=p[o]; }return t=e(t), o*=2, t>(0===o?9:1)&&(o+=1), l[n](t,o,a)[i].replace("%s",t)}function r(e,n){return((n=n?t(n):new Date)-t(e))/1e3}function o(t){for(var e=1,n=0,r=Math.abs(t);t>=p[n]&&n<h;n++){ t/=p[n], e*=p[n]; }return r%=e, r=r?e-r:e, Math.ceil(r)}function i(t){return a(t,"data-timeago")||a(t,"datetime")}function a(t,e){return t.getAttribute?t.getAttribute(e):t.attr?t.attr(e):void 0}function u(t,e){return t.setAttribute?t.setAttribute(m,e):t.attr?t.attr(m,e):void 0}function c(t,e){this.nowDate=t, this.defaultLocale=e||"en";}function d(t,e){return new c(t,e)}var f="second_minute_hour_day_week_month_year".split("_"),s="秒_分钟_小时_天_周_月_年".split("_"),l={en:function(t,e){if(0===e){ return["just now","right now"]; }var n=f[parseInt(e/2)];return t>1&&(n+="s"), [t+" "+n+" ago","in "+t+" "+n]},zh_CN:function(t,e){if(0===e){ return["刚刚","片刻后"]; }var n=s[parseInt(e/2)];return[t+n+"前",t+n+"后"]}},p=[60,60,24,7,365/7/12,12],h=6,m="data-tid",w={};return c.prototype.doRender=function(t,e,i){var a,c=r(e,this.nowDate),d=this;t.innerHTML=n(c,i,this.defaultLocale), w[a=setTimeout(function(){d.doRender(t,e,i), delete w[a];},Math.min(1e3*o(c),2147483647))]=0, u(t,a);}, c.prototype.format=function(t,e){return n(r(t,this.nowDate),e,this.defaultLocale)}, c.prototype.render=function(t,e){
	var this$1 = this;
	void 0===t.length&&(t=[t]);for(var n=0,r=t.length;n<r;n++){ this$1.doRender(t[n],i(t[n]),e); }}, c.prototype.setLocale=function(t){this.defaultLocale=t;}, d.register=function(t,e){l[t]=e;}, d.cancel=function(t){var e;if(t){ (e=a(t,m))&&(clearTimeout(e), delete w[e]); }else{for(e in w){ clearTimeout(e); }w={};}}, d});
	});

	var Locale = {
	    document: {
	        success: {
	            delete: 'El documento se eliminó correctamente'
	        },
	        error: {
	            not_found: 'No se encontró el documento',
	            invalid: 'El documento no es válido',
	            unauthorized: 'Éste documento no te pertenece',
	            bad_request: 'La solicitud no se pudo procesar',
	            validation: 'El documento contiene errores'
	        },
	        share_modal: {
	            title: 'Compartir con otros usuarios',
	            label: 'Cualquiera con el vínculo puede verlo.',
	            test_link: 'Prueba el enlace'
	        },
	        lastmod: 'La última modificación se realizó '
	    },
	    ui: {
	        title: 'Markdown Editor',
	        delete_confirmation: {
	            title: 'Escribe nuevamente el nombre del documento para borrarlo',
	            placeholder: 'Nombre del documento'
	        }
	    },
	    actions: {
	        new: 'Nuevo',
	        edit: 'Editar',
	        delete: 'Eliminar',
	        cancel: 'Cancelar',
	        add: 'Agregar',
	        confirm: 'Confirmar',
	        close: 'Cerrar',
	        saving: 'Guardando ...',
	        share: 'Compartir'
	    },
	    validation: {
	        string: 'Debe ser solo texto',
	        string_not_json: 'El contenido no debe poder convertirse en un objeto json',
	        required: 'Es requerido'
	    },
	    timeago: [
	        ['justo ahora', 'en un rato'],
	        ['hace %s segundos', 'en %s segundos'],
	        ['hace 1 minuto', 'en 1 minuto'],
	        ['hace %s minutos', 'en %s minutos'],
	        ['hace 1 hora', 'en 1 hora'],
	        ['hace %s horas', 'en %s horas'],
	        ['hace 1 día', 'en 1 día'],
	        ['hace %s días', 'en %s días'],
	        ['hace 1 semana', 'en 1 semana'],
	        ['hace %s semanas', 'en %s semanas'],
	        ['hace 1 mes', 'en 1 mes'],
	        ['hace %s meses', 'en %s meses'],
	        ['hace 1 año', 'en 1 año'],
	        ['hace %s años', 'en %s años']
	    ]
	};

	var es = Locale;

	var Locales = {
	    es: es
	};

	var locales = Locales;

	var Service$1 = {
	    timeago: timeago_min(),
	    format: function format(date) {
	        return Service$1.timeago.format(date);
	    },
	    setLocale: function setLocale(locale) {
	        if ( locale === void 0 ) locale = 'es';

	        Service$1.timeago.setLocale(locale);
	    },
	    register: function register(locale) {
	        timeago_min.register(locale, function (number, index) { return locales[locale].timeago[index]; });
	    },
	    init: function init() {
	        for (var i in locales) {
	            if (locales[i].timeago) {
	                Service$1.register(i);
	            }
	        }

	        Service$1.setLocale('es');
	    },
	};

	Service$1.init();

	/**
	 * Small i18n factory function
	 * Default options = {
	        separator: '.',
	        db: {},
	        locale: '',
	        debug: false
	   }
	 * @author Masquerade Circus (christian@masquerade-circus.net)
	 * @param {Object} options 
	 */
	var i18nFactory = function (options) {
	    if ( options === void 0 ) options = {};

	    var i18n = function (key) {
	        var parsed = key.split(i18n.separator),
	            result = i18n.db[i18n.locale],
	            next;

	        if (result === undefined) {
	            i18n.debug && console.log('The locale "' + i18n.locale + '" does not exists');
	            return key;
	        }

	        while (parsed.length) {
	            next = parsed.shift();

	            if (parsed.length > 0 && typeof result[next] !== 'object') {
	                i18n.debug && console.log('There is no "' + i18n.locale + '" translation for the key "' + key + '".');
	                return key;
	            }

	            result = result[next];
	        }

	        return result;
	    };

	    Object.assign(i18n, {
	        separator: '.',
	        db: {},
	        locale: '',
	        debug: false
	    }, options);

	    return i18n;
	};

	var Service$2 = function (string) {
	    if ( string === void 0 ) string = '';

	    return Service$2.translate(string);
	};

	Service$2.translate = function (string) {
	    return Service$2.i18n(string);
	};

	Service$2.i18n = i18nFactory({
	    debug: true, //[Boolean]: Logs missing translations to console.
	    locale: 'es', // Initial locale
	    db: locales
	});

	Service$2.setLocale = function (locale) {
	    i18n.locale = locale;
	};

	var unwanted_regex = /(Š|š|Ž|ž|À|Á|Â|Ã|Ä|Å|Æ|Ç|È|É|Ê|Ë|Ì|Í|Î|Ï|Ñ|Ò|Ó|Ô|Õ|Ö|Ø|Ù|Ú|Û|Ü|Ý|Þ|ß|à|á|â|ã|ä|å|æ|ç|è|é|ê|ë|ì|í|î|ï|ð|ñ|ò|ó|ô|õ|ö|ø|ù|ú|û|ý|þ|ÿ|Ğ|İ|Ş|ğ|ı|ş|ü|ă|Ă|ș|Ș|ț|Ț)/gi;

	var unwanted_replace = { 'Š': 'S', 'š': 's', 'Ž': 'Z', 'ž': 'z', 'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'A', 'Å': 'A', 'Æ': 'A', 'Ç': 'C', 'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E', 'Ì': 'I', 'Í': 'I', 'Î': 'I', 'Ï': 'I', 'Ñ': 'N', 'Ò': 'O', 'Ó': 'O', 'Ô': 'O', 'Õ': 'O', 'Ö': 'O', 'Ø': 'O', 'Ù': 'U', 'Ú': 'U', 'Û': 'U', 'Ü': 'U', 'Ý': 'Y', 'Þ': 'B', 'ß': 'ss', 'à': 'a', 'á': 'a', 'â': 'a', 'ã': 'a', 'ä': 'a', 'å': 'a', 'æ': 'a', 'ç': 'c', 'è': 'e', 'é': 'e', 'ê': 'e', 'ë': 'e', 'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i', 'ð': 'o', 'ñ': 'n', 'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'o', 'ø': 'o', 'ù': 'u', 'ú': 'u', 'û': 'u', 'ý': 'y', 'þ': 'b', 'ÿ': 'y', 'Ğ': 'G', 'İ': 'I', 'Ş': 'S', 'ğ': 'g', 'ı': 'i', 'ş': 's', 'ü': 'u', 'ă': 'a', 'Ă': 'A', 'ș': 's', 'Ș': 'S', 'ț': 't', 'Ț': 'T' };

	var clean = function (str) { return str.replace(unwanted_regex, function (char) { return unwanted_replace[char]; }); };

	var firstCase = function (str) { return str.charAt(0).toUpperCase() + str.slice(1); };

	var toCammelCase = function (str, separator) {
	    if ( separator === void 0 ) separator = " ";

	    var list = clean(str).split(separator),
	        i = 1,
	        l = list.length;

	    list[0] = list[0].charAt(0).toLowerCase() + list[0].slice(1);

	    for (; i < l; i++) {
	        list[i] = firstCase(list[i]);
	    }

	    return list.join("");
	};

	var toPascalCase = function (str, separator) {
	    if ( separator === void 0 ) separator = " ";

	    return firstCase(toCammelCase(str, separator));
	};

	var toSnakeCase = function (str, separator) {
	    if ( separator === void 0 ) separator = "-";

	    return clean(str).split(" ").join(separator);
	};

	var toWords = function (str, separator) {
	    if ( separator === void 0 ) separator = "-";

	    return (str.charAt(0).toUpperCase() + str.slice(1).replace(/([A-Z])/g, " $1")).split(separator).join(" ");
	};

	var String$1 = {
	    clean: clean,
	    firstCase: firstCase,
	    toPascalCase: toPascalCase,
	    toCammelCase: toCammelCase,
	    toSnakeCase: toSnakeCase,
	    toWords: toWords
	};

	var SERVICE$1 = {
	    Api: Api,
	    Markdown: Markdown,
	    Documents: Service,
	    Timeago: Service$1,
	    Lang: Service$2,
	    String: String$1
	};

	var Component = {
	    opened: false,
	    header: undefined,
	    content: undefined,
	    footer: undefined,
	    open: function open(options) {
	        if ( options === void 0 ) options = {};

	        Component.header = options.header || undefined;
	        Component.content = options.content || undefined;
	        Component.footer = options.footer || undefined;
	        Component.opened = true;
	        m.redraw();
	    },
	    close: function close(e) {
	        Component.header = undefined;
	        Component.content = undefined;
	        Component.footer = undefined;
	        Component.opened = false;
	        m.redraw();
	        e && e.preventDefault && e.preventDefault();
	    },
	    view: function view(vnode) {
	        if (!Component.opened) {
	            return '';
	        }

	        return m('dialog[data-card][open]#modal', [
	            Component.header
	                ? m('header', Component.header)
	                : '',
	            Component.content
	                ? m('section', Component.content)
	                : '',
	            Component.footer
	                ? m('footer', Component.footer)
	                : ''
	        ]);
	    }
	};

	var Component$1 = {
	    opened: false,
	    color: '',
	    content: '',
	    size: '',
	    sizes: {
	        'three-line': 120,
	        'two-line': 60,
	        '': 30
	    },
	    timeout: undefined,
	    closeAfter: 4,
	    open: function open(options) {
	        if ( options === void 0 ) options = {};

	        Component$1.closeAfter = options.closeAfter || 4;
	        Component$1.color = options.color || '';
	        Component$1.content = options.content || '';
	        for (var i in Component$1.sizes) {
	            if (Component$1.content.length <= Component$1.sizes[i]) {
	                Component$1.size = i;
	            }
	        }
	        Component$1.opened = true;
	        clearTimeout(Component$1.timeout);
	        Component$1.timeout = setTimeout(function () {
	            Component$1.close();
	        }, Component$1.closeAfter * 1000);
	    },
	    close: function close(e) {
	        Component$1.closeAfter = 4;
	        Component$1.color = '';
	        Component$1.content = '';
	        Component$1.size = '';
	        Component$1.opened = false;
	        clearTimeout(Component$1.timeout);
	        e && e.preventDefault && e.preventDefault();
	    },
	    view: function view(vnode) {
	        if (!Component$1.opened) {
	            return '';
	        }

	        return m('dialog[data-card][open]#notification', [
	            m('section', {
	                'data-background': Component$1.color + ' 50'
	            }, [
	                    m('div', {
	                        'data-list': Component$1.size
	                    }, [
	                            m('li', [
	                                m('span', Component$1.content),
	                                m('a[href="#"]', { onclick: Component$1.close }, [
	                                    m('i.icon.icofont.icofont-close[data-font="danger"]')
	                                ])
	                            ])
	                        ])
	                ])
	        ]);
	    }
	};

	var Components = {
	    Modal: Component,
	    Notification: Component$1
	};

	var Page = {
	    drawerOpened: false,
	    title: '',
	    documents: {
	        current: {
	            title: '',
	            saved: '',
	            permalink: '',
	            code: '',
	            loading: true
	        },
	        list: []
	    },
	    loading: true,
	    initialId: 0,
	    setCurrent: function setCurrent(current) {
	        // If current document is modified try to save it one last time
	        PAGE.Editor
	            .save()
	            .then(function () {
	                // Set the new current document
	                Page.documents.current = Page.documents.list[current];
	                Page.documents.current.isModified = false;
	                HELPER.Title(Page.documents.current.title);

	                // Remove emptyy documents
	                if (Page.documents.current.$loki !== undefined) {
	                    Page.documents.list.forEach(function (item, index) {
	                        if (item.isNew && item.code.trim().length === 0) {
	                            Page.documents.list.splice(index, 1);
	                        }
	                    });
	                }

	                if (!Page.documents.current.isNew) {
	                    m.route.set('/' + Page.documents.current.$loki);
	                }

	                if (Page.documents.current.isNew) {
	                    PAGE.Editor.document = Page.documents.current;
	                    PAGE.Editor.document.code = '';
	                    m.route.set('/');
	                }

	            });
	    },
	    find: function find() {
	        return SERVICE.Documents
	            .find()
	            .then(function (response) {
	                Page.documents.list = response.data;
	                Page.setCurrent(0);
	                Page.loading = false;
	            })
	            .catch(function (response) { return console.log(response); });
	    },
	    oninit: function oninit() {
	        Page.title = SERVICE.Lang('title');
	        Page.find();
	    },
	    openDeleteModal: function openDeleteModal(document) {
	        if ( document === void 0 ) document = {};

	        var name = '';
	        var valid = undefined;
	        var className = '';

	        SERVICE.Documents
	            .isValid(document, false)
	            .then(function () {
	                COMPONENT.Modal.open({
	                    content: [
	                        m('div', '' + SERVICE.Lang('ui.delete_confirmation.title')),
	                        m('.form-group' + className, [
	                            m('input[type="text"]', {
	                                placeholder: SERVICE.Lang('ui.delete_confirmation.placeholder'),
	                                oninput: function oninput(e) {
	                                    name = e.target.value;
	                                },
	                                value: name
	                            }),
	                            m('label', SERVICE.Lang('ui.delete_confirmation.placeholder'))
	                        ])
	                    ],
	                    footer: [
	                        m('nav', [
	                            m('button[data-button="default"]', {
	                                onclick: function onclick(e) {
	                                    COMPONENT.Modal.close(e);
	                                    name = '';
	                                    e.preventDefault();
	                                }
	                            }, SERVICE.Lang('actions.cancel')),
	                            m('button[data-button="danger"]', {
	                                onclick: function onclick(e) {
	                                    valid = name === document.title;
	                                    className = valid ? '.has-success' : '.has-error';
	                                    COMPONENT.Modal.content = [
	                                        m('div', SERVICE.Lang('ui.delete_confirmation.title')),
	                                        m('.form-group' + className, [
	                                            m('input[type="text"]', {
	                                                placeholder: SERVICE.Lang('ui.delete_confirmation.placeholder'),
	                                                oninput: function oninput(e) {
	                                                    name = e.target.value;
	                                                },
	                                                value: name
	                                            }),
	                                            m('label', SERVICE.Lang('ui.delete_confirmation.placeholder'))
	                                        ])
	                                    ];
	                                    if (valid) {
	                                        COMPONENT.Modal.close(e);
	                                        name = '';
	                                        SERVICE.Documents
	                                            .delete(document)
	                                            .then(function () {
	                                                Page.find();
	                                            });
	                                    }
	                                }
	                            }, SERVICE.Lang('actions.delete'))
	                        ])
	                    ]
	                });
	            });
	    },
	    openShareModal: function openShareModal(document) {
	        if ( document === void 0 ) document = {};

	        SERVICE.Documents
	            .isValid(document, false)
	            .then(function () {
	                COMPONENT.Modal.open({
	                    header: [
	                        m('h1', SERVICE.Lang('document.share_modal.title'))
	                    ],
	                    content: [
	                        m('.form-group', [
	                            m('input[type="text"]', {
	                                value: SERVICE.Api.baseUrl + '/#!/shared/' + document.$loki
	                            }),
	                            m('label', SERVICE.Lang('document.share_modal.label')),
	                            m('p.help-block', [
	                                m('a[target="_blank"]', {
	                                    href: SERVICE.Api.baseUrl + '/#!/shared/' + document.$loki
	                                }, SERVICE.Lang('document.share_modal.test_link'))
	                            ])
	                        ])
	                    ],
	                    footer: [
	                        m('nav', [
	                            m('button[data-button="default"]', {
	                                onclick: function onclick(e) {
	                                    COMPONENT.Modal.close(e);
	                                    name = '';
	                                    e.preventDefault();
	                                }
	                            }, SERVICE.Lang('actions.close'))
	                        ])
	                    ]
	                });
	            });
	    },
	    getList: function getList() {
	        if (Page.loading) {
	            return m('ul[data-list="two-line"]', [
	                m('li', [
	                    m('a[href="#"]', { onclick: function (e) { return e.preventDefault(); } }, [
	                        m('i.icon.icofont[data-background="default 300"]'),
	                        m('span[data-text-placeholder="50 md"][data-background="default 300"]'),
	                        m('small[data-text-placeholder="25 lt"][data-background="default 300"]') ]),
	                    m('a[href="#"]', { onclick: function (e) { return e.preventDefault(); } }, [
	                        m('.icon[data-icon-placeholder][data-background="default 300"]')
	                    ])
	                ])
	            ]);
	        }

	        return m('ul[data-list="two-line"]', Page.documents.list.map(function (item, index) {
	            return m('li', {
	                'data-background':
	                    (
	                        (item.isNew && Page.documents.current.isNew)
	                        || (item.$loki === Page.documents.current.$loki)
	                    )
	                        ? 'info 50'
	                        : ''
	            }, [
	                    m('a[href="#"]', {
	                        onclick: function onclick(e) {
	                            Page.setCurrent(index);
	                            e.preventDefault();
	                        }
	                    }, [
	                            m('i.icon.icofont.icofont-ebook', { 'data-background': item.id === Page.documents.current.id ? 'info' : 'default' }),
	                            item.title,
	                            m('small', SERVICE.Timeago.format(item.modifiedAt))
	                        ]),
	                    m('a[href="#"]', {
	                        onclick: function onclick(e) {
	                            Page.openDeleteModal(item);
	                            e.preventDefault();
	                        }
	                    }, [
	                            m('i.icon.icofont.icofont-ui-delete[data-font="danger"]')
	                        ])
	                ]);
	        }));
	    },
	    getNewButton: function getNewButton() {
	        if (Page.loading) {
	            return m('button[data-button="success raised new"]');
	        }

	        return m('button[data-button="success raised new"]', {
	            onclick: function onclick(e) {

	                if (Page.documents.current.isNew && Page.documents.current.code.trim().length === 0) {
	                    Object.assign(Page.documents.current, SERVICE.Documents.new());
	                    e.preventDefault();
	                    return;
	                }

	                Page.documents.list.unshift(SERVICE.Documents.new());
	                Page.setCurrent(0);
	                e.preventDefault();
	            }
	        }, 'Nuevo');
	    },
	    getDrawer: function getDrawer() {
	        return [
	            m('button[data-button][data-drawer-button]', {
	                onclick: function onclick(e) {
	                    Page.drawerOpened = !Page.drawerOpened;
	                    e.preventDefault();
	                }
	            }, m('i.icofont.icofont-navigation-menu')),
	            m('[data-drawer]', {
	                onclick: function onclick(e) {
	                    Page.drawerOpened = false;
	                    e.preventDefault();
	                },
	                open: Page.drawerOpened
	            }, [
	                    m('[data-drawer-content]', [
	                        m('[data-flexible-bar]', [
	                            m('[data-flexible-bar-media][data-background="info 700"]', [
	                                m('div[style="margin-top:50rem"]', [
	                                    m('h4', SERVICE.Lang('ui.title'))
	                                ])
	                            ])
	                        ]),
	                        Page.getNewButton(),
	                        Page.getList(),
	                        m('footer[data-background="info 700"]', [
	                            m('nav', [
	                                /* m('button', 'Changelog'),
	                                m('button', 'Roadmap') */
	                            ])
	                        ])
	                    ])
	                ])
	        ];
	    },
	    view: function view(vnode) {
	        return [
	            m('header[data-background="info 600"]',
	                PAGE.Editor.getHeader(),
	                Page.getDrawer()
	            ),
	            m('article#editor.flex.align-stretch', vnode.children),
	            PAGE.Editor.getDeleteButton(),
	            m(COMPONENT.Notification),
	            m(COMPONENT.Modal) ];
	    }
	};

	var Page$1 = {
	    document: {
	        title: '',
	        saved: '',
	        permalink: '',
	        code: '',
	        loading: true
	    },
	    loading: true,
	    interval: setInterval(function () { return Page$1.save(); }, 30000),
	    isShared: false,
	    save: function save() {
	        if (
	            Page$1.document
	            && Page$1.document.isModified
	            && !Page$1.document.isSaving
	        ) {
	            return SERVICE.Documents
	                .save(Page$1.document)
	                .then(function (document) {
	                    if (document.$loki) {
	                        m.route.set('/' + document.$loki);
	                    }
	                })
	                .catch(console.warn);
	        }

	        return Promise.resolve();
	    },
	    oninit: function oninit(vnode) {
	        Page$1.isShared = vnode.attrs.isShared;
	        if (vnode.attrs.id) {
	            SERVICE.Documents.get(vnode.attrs.id)
	                .then(function (response) {
	                    Page$1.document = response.data;
	                    Page$1.isOwner = Page$1.document.isOwner;
	                    Page$1.loading = false;
	                });
	        }
	    },
	    getHeader: function getHeader() {
	        if (Page$1.loading) {
	            return [
	                m('h1', [
	                    m('[data-text-placeholder="25 sm"][data-background="info 100"]')
	                ]),
	                m('nav', [
	                    m('button', [
	                        m('[data-icon-placeholder][data-background="info 100"]'),
	                        ' ',
	                        m('[data-text-placeholder="25 sm"][data-background="info 100"][style="width: 90rem"]')
	                    ])
	                ])
	            ];
	        }

	        if (Page$1.isShared) {
	            return [
	                m('h1', [
	                    Page$1.document.title,
	                    ' ',
	                    m('small', {}, SERVICE.Lang('document.lastmod') + SERVICE.Timeago.format(Page$1.document.modifiedAt))
	                ]),
	                m('nav', [
	                    /* !Page.isOwner
	                        ? ''
	                        : m('button', {
	                            onclick(e) {
	                                m.route.set('/' + Page.document.$loki);
	                                e.preventDefault();
	                            }
	                        }, [
	                                m('i.icon.icofont.icofont-edit'),
	                                ' Editar'
	                            ]) */
	                ])
	            ];
	        }

	        return [
	            m('h1', [
	                m('input[type="text"].title-input', {
	                    style: 'width: ' + ((Page$1.document.title.length + 1) * 10) + 'rem;',
	                    oninput: function oninput(e) {
	                        if (Page$1.document.isSaving) {
	                            return e.preventDefault();
	                        }

	                        Page$1.document.title = e.target.value;
	                        Page$1.document.isModified = true;
	                    },
	                    onblur: function onblur() {
	                        Page$1.save();
	                    },
	                    value: Page$1.document.title
	                }),
	                Page$1.document.isSaving
	                    ? m('small', [
	                        SERVICE.Lang('actions.saving'),
	                        m('[data-progress="indeterminated success"]')
	                    ])
	                    : m('small', {}, SERVICE.Lang('document.lastmod') + SERVICE.Timeago.format(Page$1.document.modifiedAt))
	            ]),
	            m('nav', [
	                !Page$1.document.$loki
	                    ? ''
	                    : m('button', {
	                        onclick: function onclick(e) {
	                            PAGE.Layout.openShareModal(Page$1.document);
	                            e.preventDefault();
	                        }
	                    }, [
	                            m('i.icon.icofont.icofont-share'),
	                            m('span', {}, ' ' + SERVICE.Lang('actions.share'))
	                        ])
	            ])
	        ];
	    },
	    getDeleteButton: function getDeleteButton() {
	        if (Page$1.loading) {
	            return m('a[href="#"][data-fab="danger"]', { onclick: function (e) { return e.preventDefault(); } });
	        }

	        return m('a[href="#"][data-fab="danger"]', {
	            onclick: function onclick(e) {
	                PAGE.Layout.openDeleteModal(Page$1.document);
	                e.preventDefault();
	            }
	        }, [
	                m('i.icon.icofont.icofont-ui-delete')
	            ]);
	    },
	    view: function view() {
	        if (Page$1.loading) {
	            return [
	                m('textarea[data-background="default 100"]'),
	                m('div.preview', [
	                    m('[data-text-placeholder="50"][data-background="default 300"][style="margin-bottom: 10rem"]'),
	                    m('[data-text-placeholder="100 sm"][data-background="default 300"][style="margin-bottom: 4rem"]'),
	                    m('[data-text-placeholder="100 sm"][data-background="default 300"][style="margin-bottom: 4rem"]'),
	                    m('[data-text-placeholder="100 sm"][data-background="default 300"][style="margin-bottom: 4rem"]'),
	                    m('[data-text-placeholder="50 sm"][data-background="default 300"][style="margin-bottom: 4rem"]') ])
	            ];
	        }

	        return [
	            m('textarea[data-background="default 100"]', {
	                oninput: function oninput(e) {
	                    if (Page$1.document.isSaving || Page$1.isShared) {
	                        return e.preventDefault();
	                    }

	                    Page$1.document.code = SERVICE.String.clean(e.target.value);
	                    Page$1.document.isModified = true;
	                },
	                onblur: function onblur(e) {
	                    Page$1.save();
	                },
	                value: Page$1.document.code
	            }),
	            m('div.preview', m.trust(SERVICE.Markdown.render(Page$1.document.code)))
	        ];
	    }
	};

	var Page$2 = {
	    view: function view(vnode) {
	        return [
	            m('header[data-background="info 600"].shared',
	                PAGE.Editor.getHeader()
	            ),
	            m('article#editor.flex.align-stretch.shared', vnode.children),
	            m(COMPONENT.Notification),
	            m(COMPONENT.Modal)
	        ];
	    }
	};

	var Pages = {
	    Layout: Page,
	    Editor: Page$1,
	    Shared: Page$2
	};

	window.m = mithril;
	window.CONFIG = CONFIG$1;
	window.HELPER = HELPER$1;
	window.SERVICE = SERVICE$1;
	window.COMPONENT = Components;
	window.PAGE = Pages;

	var ROUTES$1 = {
	    '/': {
	        render: function render(vnode) {
	            HELPER.Title('Markdown Editor');
	            vnode.attrs.key = 'index';
	            return m(PAGE.Layout, m(PAGE.Editor, vnode.attrs));
	        }
	    },
	    '/:id': {
	        render: function render(vnode) {
	            vnode.attrs.key = vnode.attrs.id;
	            return m(PAGE.Layout, m(PAGE.Editor, vnode.attrs));
	        }
	    },
	    '/shared/:id': {
	        render: function render(vnode) {
	            vnode.attrs.key = 'shared' + vnode.attrs.id;
	            vnode.attrs.isShared = true;
	            return m(PAGE.Shared, m(PAGE.Editor, vnode.attrs));
	        }
	    }

	};

	window.ROUTES = ROUTES$1;

	HELPER.Ready(function () {
	    var bodyElement = window.document.body || window.document.getElementsByTagName('body')[0];
	    m.route(bodyElement, '/', ROUTES);

	    setInterval(function () {
	        m.redraw();
	    }, 10000);
	});

}());
//# sourceMappingURL=index.min.js.map
